\subsection{Testing}

Software testing is an investigation conducted to provide stakeholders with
information about the quality of the product or service under
test.\cite{wiki:software-testing}

The following is verified during testing:
\begin{enumerate}
	\item Product meets the agreed upon requirements (validation)
	\item Product Works as expected (verification)
	\item Product can be implemented with the agreed upon characteristics
\end{enumerate}

Different software development models focus the test effort at different
points in the development process. This document will focus on agile
development, including test driven development (i.e. testing early in 
the development process).

A primary purpose of testing is to detect software failures so that
defects may be discovered and corrected. The scope of software testing
includes examination of code as well as execution of that code in
various environments and conditions.

Functional testing verifies that the software is logically correct, 
i.e. it does what it is suppose to do.

Non-functional testing refers to other aspects of the software that
may not be related to a specific function or user action, such as 
scalability, performance, security, usability, etc.

Performance is important in mobile devices because of restricted amount of
resources. We aim to develop a product that non-technical users (i.e.  bird
watchers, etc.) can understand and use, therefore usability is also an
important feature.

The later a defect is detected, the more expensive it is to fix. 
This makes test-driven development the ideal choice (where possible).

A common cause of software failure is lack of compatibility with other software,
operation systems, or hardware devices. To achieve an acceptable level of
compatibility we plan to test on Android devices of different sizes, with
different versions of the operating system. 

Ideally we would test on all supported devices (i.e. Android,
iOs, windows mobile, ...). We only have Android phones and are dependent on the
customer to provide other devices.

Reviews, walkthroughs, or inspections are considered static testing, whereas
actually executing programmed code with a given set of test cases is referred to
as dynamic testing. Both forms should be used to ensure that all features are
working as expected.

Software testing methods are traditionally divided into white- and black-box
testing, based on the point of view that a test engineer takes when designing
test cases.

White box testing occurs when the tester has access to the internal data
structures and algorithms including the code that implements these. Typically
used in unit testing with mock objects.

Black box testing is used when the tester has no knowledge of the internals, or
simply ignore the internals of the system. The purpose is to test the
abstractions provided (i.e. test a function as a whole with
pre-defined / -calculated input and output parameters).

When the coder has knowledge of the internals, but choose to do the testing from
a users point of view (black box view), some people call it "Gray box testing".
By knowing the underlying concepts of how the software works the tester makes
better-informed testing choices when testing from the outside.

Unit testing refers to tests that verify the functionality of a specific section
of code, usually at the function level. There exist many frameworks for this
type of testing, many are a member of the xUnit suite, where x is replaced by a
language specific prefix (jUnit for java, qUnit for jQuery and javascript, etc.).  
This type of testing is frequently used in test-driven development, and is a
good way to ensure that each part is working as expected. It's important to test
edge cases, and with invalid / unexpected parameters.

Integration testing is software testing that seeks to verify the interfaces
between components against a software design. This is typically conducted after
the unit tests have passed. Some integration tests can also be included in the
xUnit suite.

System testing tests a completely integrated system to verify that it meets its
requirements.

Regression testing is used to ensure that the code is functional, even after big
changes. In test-driven development this is easy to achieve using automated
testing (xUnit).

Acceptance testing is performed by the customer (often in cooperation with the
developer team), to validate that the business requirements are met.

\subsubsection{Testing cycle}

In the spirit of agile development, we intend to use automated testing, and the
following test cycle:

\begin{enumerate}
	\item Requirements analysis
	\item Test planning (strategy, plan, testbed, etc.)
	\item Test-driven development (see next list)
	\item Test reporting
	\item Test result analysis
\end{enumerate}

Test driven development (red-green):
\begin{enumerate}
	\item Write new test
	\item Test execution (test should fail, we are in the red zone)
	\item Modify code to accommodate new test
	\item Test execution (test should succeed, we are in the green zone)
	\item Regression testing (after changes in code, refactoring, and similar)
\end{enumerate}

\subsubsection{Selenium}

	Selenium is a tool for automating browsers. Primarily it is for automating
	web applications for test purposes. \cite{seleniumhq:home}
